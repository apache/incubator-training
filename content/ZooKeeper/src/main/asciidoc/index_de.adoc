////

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

////


[%notitle]
== Apache ZooKeeper
:description: Kurzeinführung in Apache ZooKeeper
:keywords: Apache ZooKeeper

image::http://www.apache.org/logos/res/zookeeper/zookeeper.png[]


== Einführung

ZooKeeper ist ein verteilter, hochverfügbarer, skalierbarer und strikt konsistenter data store


== Einführung
* Current version is 3.4.14 (April 2019)
* Eine neue Version 3.5 ist in der Entwicklung (3.5.5-beta, aus dem Mai 2019)
** Schon seit ca. 2014
** Wichtige neue Features: Dynamic Reconfiguration, "container" znode
* Eines der erste Tools aus dem Hadoop Ökosystem
* Ursprünglich bei Yahoo! gebaut, nun ein Apache Projekt


== Use Cases
* Wird von vielen Tools aus dem Hadoop Ökosystem genutzt
** HA (HBase, YARN, Hive, …)
** Koordination (HBase, ...)
* "Rezepte", die einfach mit ZooKeeper zu implementieren sind:
** Group Membership, Name Service, Configuration, Barriers, Queues, Locks, Leader Election, Two-phased commit
* Während ZooKeeper im Hadoop Ökosystem entstanden ist, wird es heute viel außerhalb genutzt
** z.B. Solr und andere Tools


== Data Model
image::data-model.png[]


== Data Model
* Hierarchie von "nodes" (znode genannt)
** Ähnlich wie in Dateisystemen
* Jeder znode kann sowohl andere nodes als Kinder haben als auch Daten
** Dies ist anders als in herkömmlichen Dateisystemen wo ein Knoten *entweder* eine Datei *oder* ein Verzeichnis ist
** Die Daten in einem Knoten sind normalerweise klein
** Im Bereich weniger Kilobyte


== Data Model
* Alle Updates sind streng sortiert und nur ein einzelner Master Prozess schreibt Daten, daher ist ZooKeeper nicht als data store für hohes Transaktionsvolumen ausgelegt
* ZooKeeper kennt "ephemeral" Nodes welche automatisch gelöscht werden wenn die Session geschlossen wird in der sie erstellt wurden
** Kann benutzt werden um verfügbare Server zu überwachen
** Man kann ein "Watch" auf ein ZNode setzen und bekommt dann eine Benachrichtigung wenn sich einer ändert


== Implementation Details
* ZooKeeper benutzt ein wire protocol basierend auf einer Bibliothek namens "Jute"
** Ursrprünglich aus Hadoop extrahiert
** Nicht außerhalb von ZooKeeper verwendet
* Es gibt native Clients für C und Java
** Andere (z.b. Python) werden von der Community verwaltetOther (e.g. Python)
* Apache Curator ist eine Java basierte Client Library, die häufig zum Zugriff verwendet wird da sie high level Konzepte in ihrer API anbietet


== Zab Protocol
* ZooKeeper kann mehrere Server verwenden, dies heißt dann ein "Ensemble"
* ZooKeeper bentutz ein Protokoll/Algorithmus namens _Zab_ um zuverlässige Lieferungen und totale und kausale Reihenfolge von Nachrichten zu bieten trotz unzuverlässiger Netzwerke
* In einem Ensemble gibt es höchstens einen Leader welcher unterstüttz wird von einer Mehrheit an Followern


== Zab Protocol
* Alle Server wählen einen Leader
** Leader ist derjenige mit den meisten Stimmen (Quorum)
** Daher meist eine ungerade Anzahl an Servern
* Alle Servers können Read requests beantworten aber alle Schreibrequests werden an den Leader weitergeleitet
** Clients können trotzdem mit einem beliebigen Server sprechen, die Requests werden automatisch weiter geleitete


== Scaling
* Alle Datenänderungen werden zur Wahl gestellt (koordiniert vom Leader)
* Je mehr Server es gibt desto länger dauert dieser Prozess
* Daher gibt es das Konzept von "participants"und "observern"
** Participants wählen mit
** Observer nehmen nicht aktiv an der Wahl teil sondern hören nur auf das Ergebnis
* Das erlaubt es ZooKeeper einfach zu skalieren ohne auf Performanzeinbusse hinzunehmen


== ZooKeeper 3.5 - Ausblick
* Container nodes
** Wenn all child nodes gelöscht wurden kann auch der container node automatisch gelöscht werden
* TTL nodes
** Wenn ein TTL node erstellt wird kann eine Time-to-Live (TTL) in ms angegeben werden
** Wenn der Knoten innehalb der TTL nicht modifiziert wurde und er keine child nodes hat wird er automatisch gelöscht


== ZooKeeper 3.5 - Ausblick
* Dynamic Reconfiguration
** Vor 3.5 waren die Mitgliedschafen in einem Ensemble statisch, ein Neustart war erforderlich um das zu ändern
** Ab Version 3.5 kann dies (und viel mehr) dynamisch geändert werden ohne, dass ein Neustart erforderlich ist
